package Analizador;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.HashMap;

import Abstract.Instruction;
import Symbol.Type;
import Symbol.TipoDato;

import Instructions.Print;
import Instructions.Statement;
import Instructions.VarAssignement;
import Instructions.VarIncDec;
import Instructions.If;
import Instructions.Match;
import Instructions.Case;
import Instructions.While;
import Instructions.DoWhile;
import Instructions.For;
import Instructions.Break;
import Instructions.Continue;
import Instructions.Function;
import Instructions.StartWith;
import Instructions.CallFunction;
import Instructions.Return;
import Instructions.VectorStatement;
import Instructions.Vector2Statement;
import Instructions.Vector1Assignement;
import Instructions.Vector2Assignement;
import Instructions.ListStatement;
import Instructions.ListAppend;
import Instructions.Struct;
import Instructions.StructStatement;
import Instructions.StructAssignement;

import Expressions.Native;
import Expressions.Arithmetics;
import Expressions.ArithmeticOperators;
import Expressions.Logic;
import Expressions.LogicOperators;
import Expressions.Relational;
import Expressions.RelationalOperators;
import Expressions.Cast;
import Expressions.VarAcces;
import Expressions.Vector1Acces;
import Expressions.Vector2Acces;
import Expressions.ListRemove;
import Expressions.StructAcces;

import Exceptions.Errores;

parser code
{:
    lexico s;
    parser(lexico s){this.s = s;}

    public LinkedList<Errores> errores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        errores.add(new Errores("Sintactico", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        errores.add(new Errores("Sintactico Irrecuperable", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

:}

action code
{:
:}

terminal String DIGITO, DOUBLE, CADENA, ID;
terminal char CHAR;
terminal String PYC, PARA, PARC, LLAVEA, LLAVEC, GUION, COMA, DOT;
terminal String PRINTLN, TRUE, FALSE, RINT, RDOUBLE, RSTRING, RBOOL, RCHAR, RVAR, RCONST, RIF, RELSE, RMATCH;
terminal String RWHILE, RDO, RFOR, RCONTINUE, RBREAK, RSTART, RVOID, RRETURN, RLIST, RNEW, RAPPEND, RREMOVE, RSTRUCT;
terminal String ADD, SUB, DENIAL, MULTI, DIV, MODULE, POWER, DOSP, EQUALP, CAST1, CAST2, CAST3;
terminal String EQUAL, NOT, SMALLER, GREATER, OR, AND, XOR, DIFFERENT, SMALLEREQ, GREATEREQ, CORA, CORC;

non terminal LinkedList<Instruction> INICIO, INSTRUCCIONES, PARAMSCALL;
non terminal LinkedList<Case> CASESLIST;
non terminal LinkedList<HashMap> PARAMSLIST, STRUCTFIELDS, STRUCTFIELDSI;
non terminal LinkedList<Object> VALORESVEC2;
non terminal LinkedList<LinkedList> VALORESVEC;
non terminal Instruction INSTRUCCION, EXPRESION, PRINT, DECLARACION, ASIGNACION, VECTORES, LISTA, LISTAAPPEND, LISTAREMOVE;
non terminal Instruction IF, MATCH, WHILE, DOWHILE, FOR, BREAK, CONTINUE, START, FUNCTION, CALLFUNCTION, RETURN, STRUCT, ISTRUCT, STRUCTACCES, ASTRUCT;
non terminal Case CASE, DEFAULT;
non terminal Type TIPOS;
non terminal Object MUTABLE;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence left NOT;
precedence left EQUAL, DIFFERENT, SMALLER, SMALLEREQ, GREATER, GREATEREQ;
precedence left ADD, SUB;
precedence left MULTI, DIV, MODULE;
precedence left POWER;
precedence left CAST3;
precedence left CAST2;
precedence left CAST1;
precedence left DENIAL;

start with INICIO;

INICIO ::= INSTRUCCIONES:a                            {: RESULT = a; :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b       {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                       {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

 INSTRUCCION ::= PRINT:a                              {: RESULT = a; :} 
            | DECLARACION:a                           {: RESULT = a; :}
            | ASIGNACION:a PYC                        {: RESULT = a; :}
            | IF:a                                    {: RESULT = a; :}
            | MATCH:a                                 {: RESULT = a; :}
            | WHILE:a                                 {: RESULT = a; :}
            | DOWHILE:a                               {: RESULT = a; :}
            | FOR:a                                   {: RESULT = a; :}
            | BREAK:a                                 {: RESULT = a; :}
            | CONTINUE:a                              {: RESULT = a; :}
            | FUNCTION:a                              {: RESULT = a; :}
            | START:a                                 {: RESULT = a; :}
            | CALLFUNCTION:a PYC                      {: RESULT = a; :}
            | RETURN:a                                {: RESULT = a; :}
            | VECTORES:a                              {: RESULT = a; :}
            | LISTA:a                                 {: RESULT = a; :}
            | LISTAAPPEND:a                           {: RESULT = a; :}
            | LISTAREMOVE:a                           {: RESULT = a; :}
            | STRUCT:a                                {: RESULT = a; :}
            | ISTRUCT:a                               {: RESULT = a; :}
            | ASTRUCT:a                               {: RESULT = a; :}
            | error PYC
            | error
;

PRINT ::= PRINTLN PARA EXPRESION:a PARC PYC           {: RESULT = new Print(a, aleft, aright); :}
;

DECLARACION ::= MUTABLE:a ID:b DOSP TIPOS:c EQUALP EXPRESION:d PYC              {: RESULT = new Statement(Boolean.parseBoolean(a.toString()), b.toString(), d, c, aleft, aright); :}
            | MUTABLE:a ID:b DOSP TIPOS:c PYC                                   {: RESULT = new Statement(Boolean.parseBoolean(a.toString()), b.toString(), c, aleft, aright); :}
;

ASIGNACION ::= ID:a EQUALP EXPRESION:b                                          {: RESULT = new VarAssignement(a, b, aleft, aright); :}
            | ID:a ADD ADD                                                      {: RESULT = new VarIncDec(a, true, aleft, aright); :}
            | ID:a SUB SUB                                                      {: RESULT = new VarIncDec(a, false, aleft, aright); :}
            | ID:a CORA EXPRESION:b CORC EQUALP EXPRESION:c                     {: RESULT = new Vector1Assignement(a, b, c, aleft, aright); :}
            | ID:a CORA EXPRESION:b CORC CORA EXPRESION:c CORC EQUALP EXPRESION:d {: RESULT = new Vector2Assignement(a, b, c, d, aleft, aright); :}
;

IF ::= RIF PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC RELSE LLAVEA INSTRUCCIONES:c LLAVEC          {: RESULT = new If(a, b, c, aleft, aright); :}
            | RIF PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC RELSE IF:c                            {: LinkedList<Instruction> tmp = new LinkedList<>(); tmp.add(c); RESULT = new If(a, b, tmp, aleft, aright); :}
            | RIF PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC                                       {: RESULT = new If(a, b, aleft, aright); :}
;

MATCH ::= RMATCH EXPRESION:a LLAVEA CASESLIST:b DEFAULT:c LLAVEC                {: RESULT = new Match(a, b, c, aleft, aright); :}
            | RMATCH EXPRESION:a LLAVEA CASESLIST:b LLAVEC                      {: RESULT = new Match(a, b, null, aleft, aright); :}
            | RMATCH EXPRESION:a LLAVEA DEFAULT:b LLAVEC                        {: RESULT = new Match(a, new LinkedList<Case>(), b, aleft, aright); :}
;

CASESLIST ::= CASESLIST:a CASE:b                      {: RESULT = a; RESULT.add(b); :}
            | CASE:a                                  {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

CASE ::= EXPRESION:a EQUALP GREATER LLAVEA INSTRUCCIONES:b LLAVEC               {: RESULT = new Case(a, b, aleft, aright); :}
;

DEFAULT ::= GUION EQUALP GREATER LLAVEA INSTRUCCIONES:a LLAVEC                  {: RESULT = new Case(null, a, aleft, aright); :}
;

WHILE ::= RWHILE PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC            {: RESULT = new While(a, b, aleft, aright); :}
;

DOWHILE ::= RDO LLAVEA INSTRUCCIONES:a LLAVEC RWHILE PARA EXPRESION:b PARC PYC  {: RESULT = new DoWhile(b, a, aleft, aright); :}
;

FOR ::= RFOR PARA ASIGNACION:a PYC EXPRESION:b PYC ASIGNACION:c PARC LLAVEA INSTRUCCIONES:d  LLAVEC         {: RESULT = new For(a, b, c, d, aleft, aright); :}
;

BREAK ::= RBREAK:a PYC                                {: RESULT = new Break(aleft, aright); :}
;

CONTINUE ::= RCONTINUE:a PYC                          {: RESULT = new Continue(aleft, aright); :}
;

FUNCTION ::= TIPOS:a ID:b PARA PARC LLAVEA INSTRUCCIONES:c LLAVEC               {: RESULT = new Function(b, new LinkedList<HashMap>(), c, a, aleft, aright); :}
            | TIPOS:a ID:b PARA PARAMSLIST:c PARC LLAVEA INSTRUCCIONES:d LLAVEC {: RESULT = new Function(b, c, d, a, aleft, aright);  :}
;

PARAMSLIST ::= PARAMSLIST:a COMA TIPOS:b ID:c         {: RESULT = a; var map2 = new HashMap<String, Object>(); 
                                                         map2.put("id",c); map2.put("type", b); RESULT.add(map2); :}
            | TIPOS:a ID:b                            {: RESULT = new LinkedList<HashMap>(); var map = new HashMap<String, Object>(); 
                                                         map.put("id",b); map.put("type", a); RESULT.add(map); :}
;

START ::= RSTART ID:a PARA PARC PYC                   {: RESULT = new StartWith(a, new LinkedList<Instruction>(), aleft, aright); :}
            | RSTART ID:a PARA PARAMSCALL:b PARC PYC  {: RESULT = new StartWith(a, b, aleft, aright); :}
;

PARAMSCALL ::= PARAMSCALL:a COMA EXPRESION:b          {: RESULT = a; RESULT.add(b); :}
            | EXPRESION:a                             {: RESULT = new LinkedList<Instruction>(); RESULT.add(a); :}
;

CALLFUNCTION ::= ID:a PARA PARC                       {: RESULT = new CallFunction(a, new LinkedList<Instruction>(), aleft, aright); :}
            | ID:a PARA PARAMSCALL:b PARC             {: RESULT = new CallFunction(a, b, aleft, aright); :}
;

RETURN ::= RRETURN:a PYC                              {: RESULT = new Return(null, aleft, aright); :}
            | RRETURN EXPRESION:a PYC                 {: RESULT = new Return(a, aleft, aright); :}
;

VECTORES ::= MUTABLE:a ID:b DOSP TIPOS:c CORA CORC EQUALP CORA VALORESVEC2:d CORC PYC                   {: RESULT = new VectorStatement(Boolean.parseBoolean(a.toString()), b, d, c, aleft, aright); :}
            | MUTABLE:a ID:b DOSP TIPOS:c CORA CORC CORA CORC EQUALP CORA VALORESVEC:d CORC PYC         {: RESULT = new Vector2Statement(Boolean.parseBoolean(a.toString()), b, d, c, aleft, aright); :}
;

VALORESVEC ::= VALORESVEC:a COMA CORA VALORESVEC2:b CORC                        {: RESULT = a; RESULT.add(b); :}
            | CORA VALORESVEC2:a CORC                                           {: RESULT = new LinkedList<LinkedList>(); RESULT.add(a); :}
;

VALORESVEC2 ::= VALORESVEC2:a COMA EXPRESION:b        {: RESULT = a; RESULT.add(b); :}
            | EXPRESION:a                             {: RESULT = new LinkedList<Object>(); RESULT.add(a); :}
;

LISTA ::= RLIST SMALLER TIPOS:a GREATER ID:b EQUALP RNEW RLIST PARA PARC PYC    {: RESULT = new ListStatement(b, a, aleft, aright); :}
;

LISTAAPPEND ::= ID:a DOT RAPPEND PARA EXPRESION:b PARC PYC                      {: RESULT = new ListAppend(a, b, aleft, aright); :}
;

LISTAREMOVE ::= ID:a DOT RREMOVE PARA EXPRESION:b PARC PYC                      {: RESULT = new ListRemove(a, b, aleft, aright); :}
;

STRUCT ::= RSTRUCT LLAVEA STRUCTFIELDS:b LLAVEC ID:a PYC                        {: RESULT = new Struct(a, b, aleft, aright); :}
;

STRUCTFIELDS ::= STRUCTFIELDS:a ID:c DOSP TIPOS:b PYC   {: RESULT = a; var map2 = new HashMap<String, Object>(); 
                                                         map2.put("id",c); map2.put("type", b); RESULT.add(map2); :}
            | STRUCTFIELDS:a ID:c DOSP ID:b PYC         {: RESULT = a; var map2 = new HashMap<String, Object>(); 
                                                         map2.put("id",c); map2.put("type", b); RESULT.add(map2); :}
            | ID:b DOSP TIPOS:a  PYC                    {: RESULT = new LinkedList<HashMap>(); var map = new HashMap<String, Object>(); 
                                                         map.put("id",b); map.put("type", a); RESULT.add(map); :}
            | ID:b DOSP ID:a  PYC                       {: RESULT = new LinkedList<HashMap>(); var map = new HashMap<String, Object>(); 
                                                         map.put("id",b); map.put("type", a); RESULT.add(map); :}
;

ISTRUCT ::= MUTABLE:a ID:b DOSP ID:c EQUALP LLAVEA STRUCTFIELDSI:d LLAVEC PYC   {: RESULT = new StructStatement(Boolean.parseBoolean(a.toString()), b, c, d, aleft, aright); :}
;

STRUCTFIELDSI ::= STRUCTFIELDSI:a COMA ID:c DOSP EXPRESION:b                    {: RESULT = a; var map2 = new HashMap<String, Object>(); 
                                                                                 map2.put("id",c); map2.put("value", b); RESULT.add(map2); :}
            | ID:b DOSP EXPRESION:a                                             {: RESULT = new LinkedList<HashMap>(); var map = new HashMap<String, Object>(); 
                                                                                 map.put("id",b); map.put("value", a); RESULT.add(map); :}
;

STRUCTACCES ::= ID:a DOT ID:b                         {: RESULT = new StructAcces(a, b, aleft, aright); :}
;

ASTRUCT ::= ID:a DOT ID:b EQUALP EXPRESION:c PYC      {: RESULT = new StructAssignement(a, b, c, aleft, aright); :}
;

MUTABLE ::= RVAR                                      {: RESULT = true; :}
            | RCONST                                  {: RESULT = false; :}
;
TIPOS ::=   RINT                                      {: RESULT = new Type(TipoDato.INTEGER); :}
            | RDOUBLE                                 {: RESULT = new Type(TipoDato.DOUBLE); :}
            | RSTRING                                 {: RESULT = new Type(TipoDato.STRING); :}
            | RCHAR                                   {: RESULT = new Type(TipoDato.CHAR); :}
            | RBOOL                                   {: RESULT = new Type(TipoDato.BOOLEAN); :}
            | RVOID                                   {: RESULT = new Type(TipoDato.VOID); :}
;

EXPRESION ::= SUB EXPRESION:a                         {: RESULT = new Arithmetics(null, a, ArithmeticOperators.DENIAL, aleft, aright); :} %prec DENIAL
            | EXPRESION:a MULTI MULTI EXPRESION:b     {: RESULT = new Arithmetics(a, b, ArithmeticOperators.POWER, aleft, aright); :} %prec POWER
            | EXPRESION:a MODULE EXPRESION:b          {: RESULT = new Arithmetics(a, b, ArithmeticOperators.MODULE, aleft, aright); :}
            | EXPRESION:a DIV EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.DIVISION, aleft, aright); :}
            | EXPRESION:a MULTI EXPRESION:b           {: RESULT = new Arithmetics(a, b, ArithmeticOperators.MULTIPLICATION, aleft, aright); :}
            | EXPRESION:a SUB EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.SUBTRACTION, aleft, aright); :}
            | EXPRESION:a ADD EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.ADDITION, aleft, aright); :}
            | EXPRESION:a EQUAL EXPRESION:b           {: RESULT = new Relational(a, b, RelationalOperators.EQUAL, aleft, aright); :}
            | EXPRESION:a DIFFERENT EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.DIFFERENT, aleft, aright); :}
            | EXPRESION:a SMALLER EXPRESION:b         {: RESULT = new Relational(a, b, RelationalOperators.SMALLER, aleft, aright); :}
            | EXPRESION:a SMALLEREQ EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.SMALLEREQUAL, aleft, aright); :}
            | EXPRESION:a GREATER EXPRESION:b         {: RESULT = new Relational(a, b, RelationalOperators.GREATER, aleft, aright); :}
            | EXPRESION:a GREATEREQ EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.GREATEREQUAL, aleft, aright); :}
            | NOT EXPRESION:a                         {: RESULT = new Logic(null, a, LogicOperators.NOT, aleft, aright); :}
            | EXPRESION:a XOR EXPRESION:b             {: RESULT = new Logic(a, b, LogicOperators.XOR, aleft, aright); :}
            | EXPRESION:a AND EXPRESION:b             {: RESULT = new Logic(a, b, LogicOperators.AND, aleft, aright); :}
            | EXPRESION:a OR EXPRESION:b              {: RESULT = new Logic(a, b, LogicOperators.OR, aleft, aright); :}
            | PARA RINT PARC EXPRESION:a              {: RESULT = new Cast(a, new Type(TipoDato.INTEGER), aleft, aright); :}%prec CAST1
            | PARA RDOUBLE PARC EXPRESION:a           {: RESULT = new Cast(a, new Type(TipoDato.DOUBLE), aleft, aright); :}%prec CAST2
            | PARA RCHAR PARC EXPRESION:a             {: RESULT = new Cast(a, new Type(TipoDato.CHAR), aleft, aright); :}%prec CAST3
            | DIGITO:a                                {: RESULT = new Native(Integer.parseInt(a), new Type(TipoDato.INTEGER), aleft, aright); :}
            | DOUBLE:a                                {: RESULT = new Native(new Double(a), new Type(TipoDato.DOUBLE), aleft, aright); :}
            | CADENA:a                                {: RESULT = new Native(a, new Type(TipoDato.STRING), aleft, aright); :}
            | CHAR:a                                  {: RESULT = new Native(a, new Type(TipoDato.CHAR), aleft, aright); :}
            | TRUE:a                                  {: RESULT = new Native(a, new Type(TipoDato.BOOLEAN), aleft, aright); :}
            | FALSE:a                                 {: RESULT = new Native(a, new Type(TipoDato.BOOLEAN), aleft, aright); :}
            | CALLFUNCTION:a                          {: RESULT = a; :}
            | LISTAREMOVE:a                           {: RESULT = a; :}
            | STRUCTACCES:a                           {: RESULT = a; :}
            | ID:a CORA EXPRESION:b CORC CORA EXPRESION:c CORC {: RESULT = new Vector2Acces(a, b, c, aleft, aright); :}
            | ID:a CORA EXPRESION:b CORC              {: RESULT = new Vector1Acces(a, b, aleft, aright); :}
            | ID:a                                    {: RESULT = new VarAcces(a, aleft, aright); :}
            | PARA EXPRESION:a PARC                   {: RESULT = a; :}
;