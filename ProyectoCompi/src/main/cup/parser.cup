package Analizador;

import java_cup.runtime.Symbol;
import java.util.LinkedList;

import Abstract.Instruction;
import Symbol.Type;
import Symbol.TipoDato;

import Instructions.Print;
import Instructions.Statement;
import Instructions.VarAssignement;
import Instructions.VarIncDec;

import Expressions.Native;
import Expressions.Arithmetics;
import Expressions.ArithmeticOperators;
import Expressions.Logic;
import Expressions.LogicOperators;
import Expressions.Relational;
import Expressions.RelationalOperators;
import Expressions.Cast;
import Expressions.VarAcces;

import Exceptions.Errores;

parser code
{:
    lexico s;
    parser(lexico s){this.s = s;}

    public LinkedList<Errores> errores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        errores.add(new Errores("Sintactico", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        errores.add(new Errores("Sintactico Irrecuperable", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

:}

action code
{:
:}

terminal String DIGITO, DOUBLE, CADENA, ID;
terminal char CHAR;
terminal String PYC, PARA, PARC;
terminal String PRINTLN, TRUE, FALSE, RINT, RDOUBLE, RSTRING, RBOOL, RCHAR, RVAR, RCONST;
terminal String ADD, SUB, DENIAL, MULTI, DIV, MODULE, POWER, DOSP, EQUALP;
terminal STRING EQUAL, NOT, SMALLER, GREATER, OR, AND, XOR, DIFFERENT, SMALLEREQ, GREATEREQ;

non terminal LinkedList<Instruction> INICIO, INSTRUCCIONES;
non terminal Instruction INSTRUCCION, EXPRESION, PRINT, DECLARACION, ASIGNACION;
non terminal Type TIPOS;
non terminal Object MUTABLE;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence left NOT;
precedence left EQUAL, DIFFERENT, SMALLER, SMALLEREQ, GREATER, GREATEREQ;
precedence left ADD, SUB;
precedence left MULTI, DIV, MODULE;
precedence left POWER;
precedence left DENIAL;

start with INICIO;

INICIO ::= INSTRUCCIONES:a                            {: RESULT = a; :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b       {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                       {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

 INSTRUCCION ::= PRINT:a                              {: RESULT = a; :} 
            | DECLARACION:a                           {: RESULT = a; :}
            | ASIGNACION:a                            {: RESULT = a; :}
            | error PYC
            | error
;

PRINT ::= PRINTLN PARA EXPRESION:a PARC PYC           {: RESULT = new Print(a, aleft, aright); :}
;

DECLARACION ::= MUTABLE:a ID:b DOSP TIPOS:c EQUALP EXPRESION:d PYC              {: RESULT = new Statement(Boolean.parseBoolean(a.toString()), b.toString(), d, c, aleft, aright); :}
            | MUTABLE:a ID:b DOSP TIPOS:c PYC                                   {: RESULT = new Statement(Boolean.parseBoolean(a.toString()), b.toString(), c, aleft, aright); :}
;

ASIGNACION ::= ID:a EQUALP EXPRESION:b PYC            {: RESULT = new VarAssignement(a, b, aleft, aright); :}
            | ID:a ADD ADD PYC                        {: RESULT = new VarIncDec(a, true, aleft, aright); :}
            | ID:a SUB SUB PYC                        {: RESULT = new VarIncDec(a, false, aleft, aright); :}
;

MUTABLE ::= RVAR                                      {: RESULT = true; :}
            | RCONST                                  {: RESULT = false; :}
;
TIPOS ::=   RINT                                      {: RESULT = new Type(TipoDato.INTEGER); :}
            | RDOUBLE                                 {: RESULT = new Type(TipoDato.DOUBLE); :}
            | RSTRING                                 {: RESULT = new Type(TipoDato.STRING); :}
            | RCHAR                                   {: RESULT = new Type(TipoDato.CHAR); :}
            | RBOOL                                   {: RESULT = new Type(TipoDato.BOOLEAN); :}
;

EXPRESION ::= SUB EXPRESION:a                         {: RESULT = new Arithmetics(null, a, ArithmeticOperators.DENIAL, aleft, aright); :} %prec DENIAL
            | EXPRESION:a MULTI MULTI EXPRESION:b     {: RESULT = new Arithmetics(a, b, ArithmeticOperators.POWER, aleft, aright); :} %prec POWER
            | EXPRESION:a MODULE EXPRESION:b          {: RESULT = new Arithmetics(a, b, ArithmeticOperators.MODULE, aleft, aright); :}
            | EXPRESION:a DIV EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.DIVISION, aleft, aright); :}
            | EXPRESION:a MULTI EXPRESION:b           {: RESULT = new Arithmetics(a, b, ArithmeticOperators.MULTIPLICATION, aleft, aright); :}
            | EXPRESION:a SUB EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.SUBTRACTION, aleft, aright); :}
            | EXPRESION:a ADD EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.ADDITION, aleft, aright); :}
            | EXPRESION:a EQUAL EXPRESION:b           {: RESULT = new Relational(a, b, RelationalOperators.EQUAL, aleft, aright); :}
            | EXPRESION:a DIFFERENT EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.DIFFERENT, aleft, aright); :}
            | EXPRESION:a SMALLER EXPRESION:b         {: RESULT = new Relational(a, b, RelationalOperators.SMALLER, aleft, aright); :}
            | EXPRESION:a SMALLEREQ EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.SMALLEREQUAL, aleft, aright); :}
            | EXPRESION:a GREATER EXPRESION:b         {: RESULT = new Relational(a, b, RelationalOperators.GREATER, aleft, aright); :}
            | EXPRESION:a GREATEREQ EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.GREATEREQUAL, aleft, aright); :}
            | NOT EXPRESION:a                         {: RESULT = new Logic(null, a, LogicOperators.NOT, aleft, aright); :}
            | EXPRESION:a XOR EXPRESION:b             {: RESULT = new Logic(a, b, LogicOperators.XOR, aleft, aright); :}
            | EXPRESION:a AND EXPRESION:b             {: RESULT = new Logic(a, b, LogicOperators.AND, aleft, aright); :}
            | EXPRESION:a OR EXPRESION:b              {: RESULT = new Logic(a, b, LogicOperators.OR, aleft, aright); :}
            | PARA RINT PARC EXPRESION:a              {: RESULT = new Cast(a, new Type(TipoDato.INTEGER), aleft, aright); :}
            | PARA RDOUBLE PARC EXPRESION:a           {: RESULT = new Cast(a, new Type(TipoDato.DOUBLE), aleft, aright); :}
            | PARA RCHAR PARC EXPRESION:a             {: RESULT = new Cast(a, new Type(TipoDato.CHAR), aleft, aright); :}
            | DIGITO:a                                {: RESULT = new Native(Integer.parseInt(a), new Type(TipoDato.INTEGER), aleft, aright); :}
            | DOUBLE:a                                {: RESULT = new Native(new Double(a), new Type(TipoDato.DOUBLE), aleft, aright); :}
            | CADENA:a                                {: RESULT = new Native(a, new Type(TipoDato.STRING), aleft, aright); :}
            | CHAR:a                                  {: RESULT = new Native(a, new Type(TipoDato.CHAR), aleft, aright); :}
            | TRUE:a                                  {: RESULT = new Native(a, new Type(TipoDato.BOOLEAN), aleft, aright); :}
            | FALSE:a                                 {: RESULT = new Native(a, new Type(TipoDato.BOOLEAN), aleft, aright); :}
            | ID:a                                    {: RESULT = new VarAcces(a, aleft, aright); :}
            | PARA EXPRESION:a PARC                   {: RESULT = a; :}
;