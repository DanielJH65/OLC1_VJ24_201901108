package Analizador;

import java_cup.runtime.Symbol;
import java.util.LinkedList;

import Abstract.Instruction;
import Symbol.Type;
import Symbol.TipoDato;

import Instructions.Print;
import Instructions.Statement;
import Instructions.VarAssignement;
import Instructions.VarIncDec;
import Instructions.If;
import Instructions.Match;
import Instructions.Case;
import Instructions.While;
import Instructions.DoWhile;
import Instructions.For;
import Instructions.Break;
import Instructions.Continue;

import Expressions.Native;
import Expressions.Arithmetics;
import Expressions.ArithmeticOperators;
import Expressions.Logic;
import Expressions.LogicOperators;
import Expressions.Relational;
import Expressions.RelationalOperators;
import Expressions.Cast;
import Expressions.VarAcces;

import Exceptions.Errores;

parser code
{:
    lexico s;
    parser(lexico s){this.s = s;}

    public LinkedList<Errores> errores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        errores.add(new Errores("Sintactico", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        errores.add(new Errores("Sintactico Irrecuperable", "No se esperaba el componente: " + s.value, s.left, s.right));
    }

:}

action code
{:
:}

terminal String DIGITO, DOUBLE, CADENA, ID;
terminal char CHAR;
terminal String PYC, PARA, PARC, LLAVEA, LLAVEC, GUION;
terminal String PRINTLN, TRUE, FALSE, RINT, RDOUBLE, RSTRING, RBOOL, RCHAR, RVAR, RCONST, RIF, RELSE, RMATCH;
terminal String RWHILE, RDO, RFOR, RCONTINUE, RBREAK;
terminal String ADD, SUB, DENIAL, MULTI, DIV, MODULE, POWER, DOSP, EQUALP;
terminal STRING EQUAL, NOT, SMALLER, GREATER, OR, AND, XOR, DIFFERENT, SMALLEREQ, GREATEREQ;

non terminal LinkedList<Instruction> INICIO, INSTRUCCIONES;
non terminal LinkedList<Case> CASESLIST;
non terminal Instruction INSTRUCCION, EXPRESION, PRINT, DECLARACION, ASIGNACION, IF, MATCH, WHILE, DOWHILE, FOR, BREAK, CONTINUE;
non terminal Case CASE, DEFAULT;
non terminal Type TIPOS;
non terminal Object MUTABLE;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence left NOT;
precedence left EQUAL, DIFFERENT, SMALLER, SMALLEREQ, GREATER, GREATEREQ;
precedence left ADD, SUB;
precedence left MULTI, DIV, MODULE;
precedence left POWER;
precedence left DENIAL;

start with INICIO;

INICIO ::= INSTRUCCIONES:a                            {: RESULT = a; :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b       {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                       {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

 INSTRUCCION ::= PRINT:a                              {: RESULT = a; :} 
            | DECLARACION:a                           {: RESULT = a; :}
            | ASIGNACION:a PYC                        {: RESULT = a; :}
            | IF:a                                    {: RESULT = a; :}
            | MATCH:a                                 {: RESULT = a; :}
            | WHILE:a                                 {: RESULT = a; :}
            | DOWHILE:a                               {: RESULT = a; :}
            | FOR:a                                   {: RESULT = a; :}
            | BREAK:a                                 {: RESULT = a; :}
            | CONTINUE:a                              {: RESULT = a; :}
            | error PYC
;

PRINT ::= PRINTLN PARA EXPRESION:a PARC PYC           {: RESULT = new Print(a, aleft, aright); :}
;

DECLARACION ::= MUTABLE:a ID:b DOSP TIPOS:c EQUALP EXPRESION:d PYC              {: RESULT = new Statement(Boolean.parseBoolean(a.toString()), b.toString(), d, c, aleft, aright); :}
            | MUTABLE:a ID:b DOSP TIPOS:c PYC                                   {: RESULT = new Statement(Boolean.parseBoolean(a.toString()), b.toString(), c, aleft, aright); :}
;

ASIGNACION ::= ID:a EQUALP EXPRESION:b                {: RESULT = new VarAssignement(a, b, aleft, aright); :}
            | ID:a ADD ADD                            {: RESULT = new VarIncDec(a, true, aleft, aright); :}
            | ID:a SUB SUB                            {: RESULT = new VarIncDec(a, false, aleft, aright); :}
;

IF ::= RIF PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC                                              {: RESULT = new If(a, b, aleft, aright); :}
            | RIF PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC RELSE LLAVEA INSTRUCCIONES:c LLAVEC   {: RESULT = new If(a, b, c, aleft, aright); :}
            | RIF PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC RELSE IF:c                            {: LinkedList<Instruction> tmp = new LinkedList<>(); tmp.add(c); RESULT = new If(a, b, tmp, aleft, aright); :}
;

MATCH ::= RMATCH EXPRESION:a LLAVEA CASESLIST:b DEFAULT:c LLAVEC                {: RESULT = new Match(a, b, c, aleft, aright); :}
            | RMATCH EXPRESION:a LLAVEA CASESLIST:b LLAVEC                      {: RESULT = new Match(a, b, null, aleft, aright); :}
            | RMATCH EXPRESION:a LLAVEA DEFAULT:b LLAVEC                        {: RESULT = new Match(a, new LinkedList<Case>(), b, aleft, aright); :}
;

CASESLIST ::= CASESLIST:a CASE:b                      {: RESULT = a; RESULT.add(b); :}
            | CASE:a                                  {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

CASE ::= EXPRESION:a EQUALP GREATER LLAVEA INSTRUCCIONES:b LLAVEC               {: RESULT = new Case(a, b, aleft, aright); :}
;

DEFAULT ::= GUION EQUALP GREATER LLAVEA INSTRUCCIONES:a LLAVEC                  {: RESULT = new Case(null, a, aleft, aright); :}
;

WHILE ::= RWHILE PARA EXPRESION:a PARC LLAVEA INSTRUCCIONES:b LLAVEC            {: RESULT = new While(a, b, aleft, aright); :}
;

DOWHILE ::= RDO LLAVEA INSTRUCCIONES:a LLAVEC RWHILE PARA EXPRESION:b PARC PYC  {: RESULT = new DoWhile(b, a, aleft, aright); :}
;

FOR ::= RFOR PARA ASIGNACION:a PYC EXPRESION:b PYC ASIGNACION:c PARC LLAVEA INSTRUCCIONES:d  LLAVEC         {: RESULT = new For(a, b, c, d, aleft, aright); :}
;

BREAK ::= RBREAK:a PYC                                {: RESULT = new Break(aleft, aright); :}
;

CONTINUE ::= RCONTINUE:a PYC                          {: RESULT = new Continue(aleft, aright); :}
;

MUTABLE ::= RVAR                                      {: RESULT = true; :}
            | RCONST                                  {: RESULT = false; :}
;
TIPOS ::=   RINT                                      {: RESULT = new Type(TipoDato.INTEGER); :}
            | RDOUBLE                                 {: RESULT = new Type(TipoDato.DOUBLE); :}
            | RSTRING                                 {: RESULT = new Type(TipoDato.STRING); :}
            | RCHAR                                   {: RESULT = new Type(TipoDato.CHAR); :}
            | RBOOL                                   {: RESULT = new Type(TipoDato.BOOLEAN); :}
;

EXPRESION ::= SUB EXPRESION:a                         {: RESULT = new Arithmetics(null, a, ArithmeticOperators.DENIAL, aleft, aright); :} %prec DENIAL
            | EXPRESION:a MULTI MULTI EXPRESION:b     {: RESULT = new Arithmetics(a, b, ArithmeticOperators.POWER, aleft, aright); :} %prec POWER
            | EXPRESION:a MODULE EXPRESION:b          {: RESULT = new Arithmetics(a, b, ArithmeticOperators.MODULE, aleft, aright); :}
            | EXPRESION:a DIV EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.DIVISION, aleft, aright); :}
            | EXPRESION:a MULTI EXPRESION:b           {: RESULT = new Arithmetics(a, b, ArithmeticOperators.MULTIPLICATION, aleft, aright); :}
            | EXPRESION:a SUB EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.SUBTRACTION, aleft, aright); :}
            | EXPRESION:a ADD EXPRESION:b             {: RESULT = new Arithmetics(a, b, ArithmeticOperators.ADDITION, aleft, aright); :}
            | EXPRESION:a EQUAL EXPRESION:b           {: RESULT = new Relational(a, b, RelationalOperators.EQUAL, aleft, aright); :}
            | EXPRESION:a DIFFERENT EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.DIFFERENT, aleft, aright); :}
            | EXPRESION:a SMALLER EXPRESION:b         {: RESULT = new Relational(a, b, RelationalOperators.SMALLER, aleft, aright); :}
            | EXPRESION:a SMALLEREQ EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.SMALLEREQUAL, aleft, aright); :}
            | EXPRESION:a GREATER EXPRESION:b         {: RESULT = new Relational(a, b, RelationalOperators.GREATER, aleft, aright); :}
            | EXPRESION:a GREATEREQ EXPRESION:b       {: RESULT = new Relational(a, b, RelationalOperators.GREATEREQUAL, aleft, aright); :}
            | NOT EXPRESION:a                         {: RESULT = new Logic(null, a, LogicOperators.NOT, aleft, aright); :}
            | EXPRESION:a XOR EXPRESION:b             {: RESULT = new Logic(a, b, LogicOperators.XOR, aleft, aright); :}
            | EXPRESION:a AND EXPRESION:b             {: RESULT = new Logic(a, b, LogicOperators.AND, aleft, aright); :}
            | EXPRESION:a OR EXPRESION:b              {: RESULT = new Logic(a, b, LogicOperators.OR, aleft, aright); :}
            | PARA RINT PARC EXPRESION:a              {: RESULT = new Cast(a, new Type(TipoDato.INTEGER), aleft, aright); :}
            | PARA RDOUBLE PARC EXPRESION:a           {: RESULT = new Cast(a, new Type(TipoDato.DOUBLE), aleft, aright); :}
            | PARA RCHAR PARC EXPRESION:a             {: RESULT = new Cast(a, new Type(TipoDato.CHAR), aleft, aright); :}
            | DIGITO:a                                {: RESULT = new Native(Integer.parseInt(a), new Type(TipoDato.INTEGER), aleft, aright); :}
            | DOUBLE:a                                {: RESULT = new Native(new Double(a), new Type(TipoDato.DOUBLE), aleft, aright); :}
            | CADENA:a                                {: RESULT = new Native(a, new Type(TipoDato.STRING), aleft, aright); :}
            | CHAR:a                                  {: RESULT = new Native(a, new Type(TipoDato.CHAR), aleft, aright); :}
            | TRUE:a                                  {: RESULT = new Native(a, new Type(TipoDato.BOOLEAN), aleft, aright); :}
            | FALSE:a                                 {: RESULT = new Native(a, new Type(TipoDato.BOOLEAN), aleft, aright); :}
            | ID:a                                    {: RESULT = new VarAcces(a, aleft, aright); :}
            | PARA EXPRESION:a PARC                   {: RESULT = a; :}
;